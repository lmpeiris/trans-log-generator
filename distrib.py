#!/usr/bin/python3

import sys
import numpy as np
import time
import datetime
from ScriptApiClass import ScriptTransformApi
sys.path.insert(0, 'lib')
from DistributionClass import DistributionClass

# TODO: update random generator for new versions of numpy, see https://numpy.org/doc/stable/reference/random/index.html

api = ScriptTransformApi(sys.argv)
# following variable decides whether to use numpy write or not
numpy_write = True
api.start_timer()
# all distributions are generated by distribution class
# generation done here except for biasedrandom
if api.distrib != 'biased_random':
    distribution = DistributionClass(api.distrib, api.field_format, api.record_count, api.value_args)
    ran_array = distribution.get_numpy_array()
    api.stop_timer('numpy distribution generation')
# ignore PEP errors for ran_array

# -------- conversions and writing to files ------------------------------------
filename = api.outfile

if api.field_format == 'enum':
    numpy_write = False
    adv_conf = api.read_adv_conf()
    elements_list = []
    if api.distrib == 'percentage' or 'biased_random':
        elements = adv_conf['elements']
        # verify whether counts add up to 100, using generator expression
        total_count = sum(x['count'] for x in elements)
        if total_count != 100 and api.distrib == 'percentage':
            print('ERROR: total count should be 100 when using percentage. current value: ' + str(total_count))
            exit(13)
        print('DEBUG: populating elements list of ' + str(total_count))
        # using outer and inner loops. _ indicates throwaway temp var
        elements_list = [x['enum'] for x in elements for _ in range(x['count'])]
        if api.distrib == 'biased_random':
            # we skipped distrib generation at the top since we didn't know the count entries
            print('DEBUG: generating entries for biased_random')
            ran_array = DistributionClass.get_random_integers(0, total_count - 1, api.record_count)
            api.stop_timer('numpy distribution generation')
    else:
        if api.value_args[0] != '0':
            print('WARN: to capture all enum entries, first argument should be zero. Check whether this was intended.')
        match adv_conf['source']:
            case 'csv_read':
                # compile unique values by reading a csv
                import csv
                csv_file = adv_conf['csv_read']['csv_file']
                column_index = adv_conf['csv_read']['column']
                print('INFO: Reading column: ' + str(column_index) + ' from ' + csv_file)
                with open(csv_file, 'r') as csvfile:
                    reader = csv.reader(csvfile, delimiter='|')
                    for row in reader:
                        value = row[column_index]
                        if value not in elements_list:
                            elements_list.append(value)
                print('DEBUG: enum records: ' + str(elements_list))
            case 'elements':
                # any other distribution, including random
                elements = adv_conf['elements']
                elements_list = [x['enum'] for x in elements]
        # enum matching cannot handle floats
        if api.distrib not in ['roundrobin', 'random']:
            ran_array = ran_array.astype(int)
    # generate enum list
    # ignore PEP errors for ran_array
    ran_list = DistributionClass.get_enum(elements_list, ran_array)
    api.stop_timer('enum mapping')
    api.list_bulk_write(ran_list)
    api.stop_timer('Writing to disk', False)


if api.field_format == 'equation':
    from sympy.abc import x
    from sympy.parsing.sympy_parser import parse_expr
    math_expression = api.value_args[3]
    parsed_expression = parse_expr(math_expression)
    distrib_var_cache = int(api.read_tlg_config('distrib_var_cache'))
    if distrib_var_cache == 1:
        print('WARN: distrib_var_cache is on. this flattens your chosen distribution to be integers')
    index = 0
    y_dict = {}
    y_list = []
    cache_hits = 0
    for i in ran_array:
        # i gives the value distribution var
        if distrib_var_cache == 1:
            # if distribution variable caching is on, we are using integer to better cache
            i = int(i)
        if i in y_dict:
            y = y_dict[i]
            cache_hits += 1
        else:
            y = parsed_expression.evalf(subs={x: i})
            y_dict[i] = y
        index += 1
        y_list.append(y)
    print('INFO: cache hit ratio: ' + str(cache_hits/api.record_count))
    ran_array = np.array(y_list)


# Date conversions: cannot use numpy text save for this, using standard file write
# TODO: test using pandas datetime and series write to disk and see whether its is faster
if api.field_format == 'datetime' or api.field_format == 'time' or api.field_format == 'date' or api.field_format == 'customDT':
    numpy_write = False
    date_time_format = api.value_args[2]
    file_handle = open(filename, 'w', 1024*1024*4)
    if api.isRepeated:
        print("DEBUG - time conversion; repeating is enabled, repeat " + str(api.num_repeat) + " times")
        for i in ran_array:
            converted_string = time.strftime(date_time_format, time.localtime(i))
            for x in range(1, api.num_repeat + 1, 1):
                file_handle.write(converted_string + '\n')
    else:
        print("DEBUG - time conversion; repeating is disabled")
        for i in ran_array:
            file_handle.write(time.strftime(date_time_format, time.localtime(i)) + '\n')
    file_handle.close()
    api.stop_timer('converting and writing to disk', False)
    if api.isPlotted:
        print("DEBUG - PLOT is not supported for this distribution")
        api.isPlotted = False

if api.field_format == 'millis' or api.field_format == 'micros':
    # special writer for timestamp (millis and micros)
    print("DEBUG - using micros time conversion")
    numpy_write = False
    micros_format = api.value_args[2]
    file_handle = open(filename, 'w', 1024*1024*4)
    if api.isRepeated:
        print("DEBUG - repeating is enabled, repeat " + str(api.num_repeat) + " times")
    if api.field_format == 'millis':
        millis = True
        print("DEBUG - cropping to millis")
    else:
        millis = False
    print("DEBUG - time conversion on " + api.field)
    for i in ran_array:
        if millis:
            converted_string = datetime.datetime.fromtimestamp(i/1000000).strftime(micros_format)[:-3]
        else:
            converted_string = datetime.datetime.fromtimestamp(i/1000000).strftime(micros_format)
        if api.isRepeated:
            for x in range(1, api.num_repeat + 1, 1):
                file_handle.write(converted_string + '\n')
        else:
            file_handle.write(converted_string + '\n')
    file_handle.close()
    api.stop_timer('converting and writing to disk', False)
    if api.isPlotted:
        print("DEBUG - PLOT is not supported for this distribution")
        api.isPlotted = False


# plot fields which is still plotting true
if api.isPlotted:
    api.start_timer()
    import matplotlib.pyplot as plt
    plot_type = api.read_tlg_config('plot_type')
    print("DEBUG - " + str(plot_type) + " plotting is enabled for this column")
    plt.title(api.field + " distribution")

    if plot_type == 'scatter':
        plt.xlabel('array index')
        x_axis = np.arange(1, api.record_count + 1, 1)
        plt.plot(x_axis, ran_array, ScriptTransformApi.read_tlg_config('plotting_format'))

    if plot_type == 'histogram':
        plt.ylabel('Frequency')
        plt.xlabel(api.field + ' value')
        plt.hist(ran_array, bins=int(api.read_tlg_config('plot_bars')))

    plt.savefig(ScriptTransformApi.read_tlg_config('output_location') + "/" + api.field + ".png", bbox_inches="tight")
    api.stop_timer('plotting')

# if numpy write is still true, write them using numpy which is extremely fast
if numpy_write:
    print('Items received to save by numpy: ' + str(ran_array.size))
    api.start_timer()
    if api.field_format == 'integer':
        formatting = '%.' + '0f'
    else:
        number_of_decimals = api.value_args[2]
        formatting = '%.' + number_of_decimals + 'f'

    if api.isRepeated:
        print("DEBUG - numpy write section: repeating is enabled, repeat " + str(api.num_repeat) + " times")
        np.savetxt(filename, np.repeat(ran_array, api.num_repeat), formatting)
    else:
        print("DEBUG - numpy write section: repeating is disabled")
        np.savetxt(filename, ran_array, formatting)
    api.stop_timer('numpy write')

print("INFO - exiting distrib.py")
